<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="en-US">
<HEAD>
<META NAME="description"
 CONTENT="master class concordance for John Dlugosz's Repertoire Project.">
<META NAME="keywords"
 CONTENT="Repertoire documentation class index">
<TITLE>Class Summary</TITLE>
<LINK REL="STYLESHEET" HREF="info.css" TYPE="text/css">
<META name="date" content="2006-10-27">
<STYLE TYPE="text/css">
.ib /* info block */ {
   white-space: pre;
   color: green;
   background-color: white;
   font-family: Arial, sans-serif;
   font-size: 1em;
   margin-left: 0.5in;
   }

.ib EM {
	font-weight: bold;
	background: inherit;
	}

HR	{
	border: solid;
	background-color: black;
	height: 10px;
	border-radius: 5px;
	-moz-border-radius: 5px;
   }
</STYLE>
</HEAD>

<BODY>
<IFRAME id="page_banner" src="page_banner.html" scrolling="no">banner</IFRAME>

<P><A HREF="class_summary_index.html" TARGET="index"><IMG SRC="../../img/blueleft.gif" ALT="left-pointing blue arrow"> click to put Class Index into the index pane</A></P>

<A NAME="toptop"></A>



<A NAME="A"></A>

<HR id="Ab">
<H2 id="abstract_command_object">abstract_command_object</H2>
<P class="ib">library: classics
header: command_object.h
usage: main API</P>

<P>This is a common interface used for command objects.  It has a virtual <code>operator()</code> function,
which is to be invoked by the consumer of the command.</P>
<P>See <A HREF="Classics/abstract_command_object.html#toptop"><code>abstract_command_object</code></A> documentation.</P>
<P>See also class <A HREF="#APC_server"><code>APC_server</code></A>.</P>


<HR id="Ad">
<H2>address_t</H2>
<P class="ib">library: classics
header: common.h
usage: main API</P>
<P>
A typedef for an integer that is the same size as a pointer.  It is designed for clairity when manipulating pointers as ints,
and for portability between 32-bit and 64-bit platforms.  It is defined as <code>unsigned</code> <code>int</code> under
Win32.  It is also defined as <code>__int64</code> for 64-bit windows, but this is provisional since that is not supported yet.
</P>


<HR id="Ap">
<H2 id="APC_server">APC_server</H2>
<P class="ib">library: classics
header: APC_server.h
usage: main API</P>
<P>
This class creates and manages a thread that can then be fed work via
a queue of command objects.
</P>
<P>See <A HREF="Classics/APC_server.html#toptop" class="code">APC_server</A> documentation.</P>
<P>See also class <A HREF="#abstract_command_object" class="code">abstract_command_object</A>.</P>


<HR id="At">
<H2 id="atomic_counter">atomic_counter</H2>
<P class="ib">library: classics
header: atomic_counter.h
usage: template, main API</P>
<P>
This provides a counter that can be incremented (or decremented) and tested
in a single thread-safe unbroken operation.  It is specifically needed for
reference counting in the <A HREF="Classics/handle_index.html" TARGET="index" class="code">handle</A> classes.
</P>
<P>See <A HREF="Classics/atomic_counter_index.html" TARGET="index"><code>atomic_counter</code></A> class index.</P>

<HR id="Au">
<H2>auto_COM_ptr</H2>
<P class="ib">library: classics
header: auto_COM_ptr.h
usage: template, main API</P>
<P>
*** docs in .txt file, needs to be added to the documentation base.
</P>


<A NAME="B"></A>

<HR id="Ba">
<H2 id="baro">baro</H2>
<P class="ib">library: classics
header: pointers.h
usage: template, main API</P>
<P>A reference-counted smart pointer for "weak references".  See the <A HREF="Classics/handle_index.html" TARGET="index">
handle class index</A> for more information.
</P>


<HR id="By">
<H2>byte</H2>
<P class="ib">library: classics
header: common.h
usage: main API</P>
<P>
A typedef for <code>unsigned</code> <code>char</code>.  This is meant for 8-bit data as a small integer, to
distinguish it from character strings.
</P>


<A NAME="C"></A>

<HR id="Ca">
<H2 id="exception::callback">callback, exception</H2>
<P class="ib">library: classics
header: exception.h
usage: main API</P>
<P>
This abstract base class is used with the <A
HREF="#exception::register_callback"><code>exception::register_callback</code></A> class to
provide automatic recording of data when an <A HREF="#exception"><code>exception</code></A> object is created.
See the <A HREF="Classics/exception_callback.html">documentation</A> for details.
</P>


<HR>
<H2 id="can_handle">can_handle</H2>
<P class="ib">library: classics
header: pointers.h
usage: main API</P>
<P>
Used as a base class, it provides a simple way to make an object capable of being
used with the &ldquo;handle&rdquo; family of smart pointers.  See XXXX [[XREF goes here]] in the handle User’s Guide for
more information.
</P>


<HR id="Ch">
<H2>chdata</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>

<P>This class is used internally by the <A HREF="#vararray"><code>vararray</code></A> implementation.
</P>


<HR id="Cl">
<H2>cloaked_pointer</H2>
<P class="ib">library: classics
header: cloaked_pointer.h
usage: template, main API</P>

<P>NEEDS DOCUMENTATION
</P>

<HR>
<H2>close_Kernel_HANDLE</H2>
<P class="ib">library: classics
header: close_handle.h
usage: main API</P>
<P>
Define one of these to make a OS Kernel <code>HANDLE</code> behave as if it had a destructor which
closes the handle when it goes out of scope.
</P>


<HR>
<H2 id="closure_stdcall_to_thiscall">closure_stdcall_to_thiscall</H2>
<P class="ib">library: classics
header: Classics/closure.h
usage: internal</P>
<P>The magic part of dynamically creating a thunk, abstracted out of <A HREF="#member_callback_thunk" class="code">member_callback_thunk</A></P>

<P>See the <A HREF="Classics/closure.html#toptop">Closure Documentation</A> for more details.</P>


<HR id="Co">
<H2 id="const_baro">const_baro</H2>
<P class="ib">library: classics
header: pointers.h
usage: template, main API</P>
<P>A reference-counted smart pointer for "weak references".  See the <A HREF="Classics/handle_index.html" TARGET="index">
handle class index</A> for more information.
</P>


<HR>
<H2 id="const_iterator">const_iterator</H2>
<P class="ib">library: classics
header: vararray.h
usage: template, main API</P>

<P>This is used to iterate over <code>vararray</code> collections.</P>
<P>See <A HREF="Classics/vararray_guide.html#7">Iterators</A> in the User’s Guide,
or the <A HREF="Classics/iterator.html">reference</A>.
</P>


<HR>
<H2 id="const_handle">const_handle</H2>
<P class="ib">library: classics
header: pointers.h
usage: template, main API</P>
<P>A reference-counted smart pointer.  For more information, see <A HREF="Classics/handle_index.html" TARGET="index">
handle class index</A>.</P>


<HR>
<H2 id="cow">cow</H2>
<P class="ib">library: classics
header: pointers.h
usage: template, main API</P>
<P>A reference-counted smart pointer having <I>Copy-On-Write</I> semantics.
For more information, see the <A HREF="Classics/handle_index.html" TARGET="index">
handle class index</A>  or the <A HREF="Classics/handle/cow_usage.html#toptop" TARGET="info"><code>cow</code> User&rsquo;s Guide</A>.
</P>


<HR id="Cr">
<H2 id="critical_section">critical_section</H2>
<P class="ib">library: classics
header: critical_section.h
usage: main API</P>
<P>
A simple mechanism for mutual exclusion, based on the NT <code>CriticalSection</code> mechanism.
</P>
<p>See <A HREF="Classics/critical_section.html"><code>critical_section</code></a> documentation.</p>
<P>See also class <A HREF="#event_flag"><code>event_flag</code></A>.</P>


<A NAME="D"></A>

<HR id="Da">
<H2 id="data_t">data_t</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>
<P>This class is used by the vararray to manipulate the elements of the collection.
This is an abstract class, containing virtual functions for coping, creating, and
destroying elements.  The derived classes <A HREF="#s_data_t"><code>s_data_t</code></A> and
<A HREF="#g_data_t"><code>g_data_t</code></A> provide actual
implementations.
</P>


<HR id="De">
<H2 id="debug_object_count_t">debug_object_count_t</H2>
<P class="ib">library: classics
header: debug_object_count.h
usage: debugging</P>
<P>
This allows leaked objects to be reported automatically at program termination.
</P>


<HR id="Di">
<H2>Dialog_message_tap</H2>
<P class="ib">library: Tomahawk
header: Dialog_message_tap.h
usage: main API</P>
<P>This is derived from <A HREF="#message_tap" class="code">message_tap</A>.  It provides C++ class object control around
model dialog boxes, modeless dialog boxes, and property page sheets.</P>
<P>See <A HREF="Tomahawk/Dialog_message_tap_index.html" TARGET="index"><code>Dialog_message_tap</code></A> documentation.</p>


<HR>
<H2>dimensional</H2>
<P class="ib">library: classics
header: dimensional.h
usage: main API</P>
<P>
A template used to create a dimentional quantity.  An ordinary number could
represent a number of feet or a number of seconds, but what does it mean
to add them together?  This template allows you to create Distance and
Time as distinct types without loss of efficiency.
</P>
<p>See <A HREF="Classics/dimensional.html#toptop"><code>dimensional</code></a> documentation.</p>


<A NAME="E"></A>

<HR id="Ea">
<H2 id="eagduru">eagduru</H2>
<P class="ib">library: tomahawk
header: eagduru.h
usage: main API</P>
<P>
</P>
<p>See <A HREF="Tomahawk\eagduru_index.html" TARGET="index"><code>eagduru</code> class index</a> for
more information.</p>


<HR id="Ev">
<H2 id="event_flag">event_flag</H2>
<P class="ib">library: classics
header: event_flag.h
usage: main API</P>
<P>
This class encapsulates a Win32 event object.  It shields the user from the raw system
calls (and specifically prevents inclusion of RatWin headers), and provides robust
error checking.
</P>
<p>See <A HREF="Classics/event_flag.html"><code>event_flag</code></a> documentation.</p>
<P>See also class <A HREF="#critical_section"><code>critical_section</code></A>.</P>


<HR id="Ex">
<H2 id="exception">exception</H2>
<P class="ib">library: classics
header: exception.h
usage: main API</P>
<P>
This is used to represent error conditions.  An <code>exception</code> object is thrown to indicate
an error.  Note that <code>classics::exception</code> is derived from <code>std::exception</code>.
</P>
<p>See <A HREF="Classics/exception_index.html" TARGET="index"><code>exception</code> class index</a> for
more information.</p>


<HR>
<H2 id="exception_value_logger">exception_value_logger</H2>
<P class="ib">library: classics
header: exception.h
usage: main API</P>
<P>
This parameterized class makes it simple to log named attributes when an
<A HREF="#exception"><code>exception</code></A> object is created.  It is called <code>exception_value_logger</code> rather than
<code>exception::value_logger</code> because when this was written Microsoft’s compiler didn’t like templates
declared inside classes.</P>

<P>See the <A HREF="Classics/exception_callback.html">documentation</A> for details.
</P>


<A NAME="F"></A>

<HR id="Fi">
<H2 id="filename_t">filename_t</H2>
<P class="ib">library: classics
header: filename.h
usage: main API</P>
<P>
This class represents a file name in a format that can be parsed and manipulated as
a list of parts.  It can handle either a PC file system name, a URL, or others.</P>
<P>See <A HREF="Classics/filename_t_index.html" TARGET="index">
<code>filename_t</code> class index</A> for more information.</P>


<HR>
<H2 id="filename_t_base">filename_t_base</H2>
<P class="ib">library: classics
header: filename.h
usage: implementation detail</P>
<P>
This class is split out of <A HREF="#filename_t"><code>filename_t</code></A> to isolate the low-level features.  This
makes it simple to redo the underlying implementation of how <I>parts</I> are
stored and parsed, without affecting the higher-level functionality.  Splitting
it up this way also helps define testing requirements.

<HR>
<H2 id="filename_t::filesystem_t">filesystem_t</H2>
<P class="ib">library: classics
<B>nested in: filename_t</B>
header: filename.h
usage: advanced API</P>
<P>
This abstract base class is used to provide details about the
actual file system, and to customize the behavior of <code>filename_t</code>.
See <A HREF="Classics/filename_t_guide.html#3"><code>filename_t</code> User’s Guide</A>
for more information.</P>
<P>Concrete types supplied are <A HREF="#filename_t::PC_filesystem_t"><code>PC_filesystem_t</code></A>
and <A HREF="#filename_t::URL_filesystem_t"><code>URL_filesystem_t</code></A>.</P>


<HR>
<H2>fixed_auto_buffer</H2>
<P class="ib">library: classics
header: fixed_auto_buffer.h
usage: main API</P>
<P>
This class is used to provide <code>auto</code> (local variables allocated on the stack) arrays (or binary buffers) whose size is not
known until run time.  It has a low overhead compared to other collection-type
classes.
</P>


<HR id="Fl">
<H2 id="flagword">flagword</H2>
<P class="ib">library: classics
header: flagword.h
usage: template, main API</P>
<P>
This parameterized class is used to create sets of flags, such as a bunch
of options passed as a single parameter.
</P>
<p>See <A HREF="Classics/flagword.html"><code>flagword</code></a> documentation.</p>


<A NAME="G"></A>

<HR>
<H2 id="g_data_t">g_data_t</H2>
<P class="ib">library: classics
header: vararray.h
usage: template, internal</P>
<P>This template is a concrete class derived from <A HREF="#data_t"><code>data_t</code></A>.
It is instantiated by
each <A HREF="#vararray_g"><code>vararray_g</code></A> with the same type argument.
That is, a <code>vararray_g&lt;complex&gt;</code> would
use a <code>g_data_t&lt;complex&gt;</code> to match.
</P>


<HR id="Ge">
<H2>generic_2D_point</H2>
<P class="ib">library: classics
header: 2D_point.h, point_ios.h
usage: template, main API</P>
<P>
This is a 2-dimentional point.  It is intended to provide common code for various
flavors of “points” needed, including <code>long</code>, <code>short</code>, and <code>double</code>.
</P>


<HR>
<H2>generic_string</H2>
<P class="ib">library: classics
header: string.h
usage: template, main API</P>
<P>
This is a general string class.  See <A HREF="#string"><code>string</code></A> and
<A HREF="#wstring"><code>wstring</code></A>.</P>
<P>See <A HREF="Classics/string.html"><code>generic_string</code></A> documentation</P>


<A NAME="H"></A>

<HR id="Ha">
<H2 id="handle">handle</H2>
<P class="ib">library: classics
header: pointers.h
usage: template, main API</P>
<P>A reference-counted smart pointer.  See the <A HREF="Classics/handle_index.html" TARGET="index">
<code>handle</code> class index</A> for more information.
</P>


<HR>
<H2>handle_structure</H2>
<P class="ib">library: classics
header: pointers.h
usage: internal</P>
<P>This is a base class used to factor out common code from all the smart pointer
templates, including
<A HREF="#handle" class="code">handle</A>,
<A HREF="#const_handle" class="code">const_handle</A>,
<A HREF="#cow" class="code">cow</A>,
<A HREF="#baro" class="code">baro</A>, and
<A HREF="#const_baro" class="code">const_baro</A>.


<HR>
<H2>handle_structure_nt</H2>
<P class="ib">library: classics
header: pointers.h
usage: internal</P>
<P>A non-template base class to bring out common code from the <code>handle_structure</code> class.
</P>


<HR id="Hs">
<H2 id="hsoft">hsoft</H2>
<P class="ib">library: ratwin
header: base.h
namespace:  ratwin::base
usage: template
</P>
<P>
This goes with the various Windows <code>HANDLE</code> types.  It is a soft-typed <code>HANDLE</code>, allowing you to
use the proper kind of <code>HANDLE</code>, or a generic untyped <code>HANDLE</code>, but <I>not</I> a known improper
type of <code>HANDLE</code>.</P>
<P>Making a parameter of type <code>HANDLE</code> would accept any kind of <code>HANDLE</code>:
<code>Kernel_HANDLE</code>, <code>HMENU</code>, <code>HKEY</code>, etc.  That is
usually too weakly typed, and defeats the purpose of having strong <code>HANDLE</code> types.  But a parameter of type
<code>hsoft&lt;HMENU&gt;</code> would allow you to pass a <code>HMENU</code> or a <code>HANDLE</code> only, and
reject a <code>HKEY</code>, <code>Kernel_HANDLE</code>, and all the rest at compile time.
</P>


<HR id="Hw">
<H2 id="HWND_vpapa">HWND_vpapa</H2>
<P class="ib">library: tomahawk
header: HWND_vpapa.h
usage: advanced
</P>
<P>This is a class that makes a correspondance between a C++ class w/reference counting, and
a Windows <code>HWND</code> handle.  It is a virtual base class of all the Tomahawk classes that
provide functionality for a Window object.</P>
<P>See <A HREF="Tomahawk/HWND_vpapa_index.html" TARGET="index">index for <code>HWND_vpapa</code> class documentation</A>
in the index pane.
</P>


<HR id="Hy">
<H2 id="hypothetical_trug">hypothetical_trug</H2>
<P class="ib">library: classics
header: trug.h
usage: template, advanced
</P>
<P>This template lists the members that are required for a class to be a <A HREF="#trug">trug</A>.
It also provides some help in
implementing them, so a derived class need do very little to create a trug class.  The name <I>hypothetical</I>
is used in the same manner as <I>abstract</I>.  This is not abstract in the C++ sence because the members
are not virtual.  I use <I>hypothetical</I> for template metaprogramming in the same sence as <I>abstract</I>
or <I>interface</I> is for run-time polymorphism.</P>
<P>For more information, see <A HREF="Classics/trug_guide.html#hypothetical">the section in the
<I>trug User’s Guide</I></A>.


<A NAME="I"></A>


<HR id="In">
<H2>index_t</H2>
<P class="ib">library: classics
<B>nested in: filename_t</B>
header: filename_t.h
usage: internal</P>
<P>This is used by the <A HREF="#filename_t"><code>filename_t</code></A> to index the various “parts” of the
string it is holding.
</P>



<HR>
<H2>intermediate</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>
<P>
This class is used internally by the <A HREF="#vararray"><code>vararray</code></A> implementation.
</P>


<HR id="It">
<H2>iterator (global)</H2>
<P class="ib">library: classics
header: vararray.h
usage: main API</P>

<P>This is used to iterate over <A HREF="#vararray" class="code">vararray</A> collections.</P>
<P>See <A HREF="Classics/vararray_guide.html#7">Iterators</A> in the Vararray User’s Guide,
or the <A HREF="Classics/iterator.html">Iterator Reference</A>.
<P>See also <A HREF="#const_iterator" class="code">const_iterator</A>.
</P>


<HR>
<H2 id="exception::iterator">iterator (exception::iterator)</H2>
<P class="ib">library: classics
<B>nested in: <A HREF="#exception">exception</A></B>
header: exception.h
usage: main API</P>
<P>
This is used to easily access the information in an <A HREF="#exception" class="code">exception</A> object.  See the
<A HREF="Classics/exception_iterator.html">documentation</A> for details.
</P>


<A NAME="L"></A>

<HR id= "La">
<H2 id="launch_thread">launch_thread</H2>
<P class="ib">library: classics
header: thread.h
usage: template, main API</P>
<P>Provides an easy way to start a thread.  See the <A HREF="Classics/launch_thread.html#toptop">documentation page</A> for this class.
</P>

<HR id="Li">
<H2 id="lifetime">lifetime</H2>
<P class="ib">library: classics
header: pointers.h
usage: protected or advanced API</P>

<A NAME="M"></A>

<HR id="Ma">
<H2>make_alias_t</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>
<P>This is a dummy type used only to define the <code>make_alias</code> constant.</P>
<P>See <A HREF="Classics/vararray_guide.html#5">Reference Counting&mdash;COW or alias</A> in
the <code>vararray</code> User’s Guide.
</P>


<HR id="Me">
<H2 id="member_callback_thunk">member_callback_thunk</H2>
<P class="ib">library: classics
header: Classics/closure.h
usage: public</P>
<P>Generates a <code>__stdcall</code> function that supplies a <code>this</code> pointer
and jumps to a member function.</P>

<P>See the <A HREF="Classics/closure.html#toptop">Closure Documentation</A> for more details.</P>


<HR>
<H2 id="message_tap">message_tap</H2>
<P class="ib">library: Tomahawk
header: message_tap.h
usage: main API</P>
<P>...........</P>
<P>See <A HREF="Tomahawk/message_tap_index.html" TARGET="index">index for <code>message_tap</code> class documentation</A>
in the index pane.
</P>



<HR id="Mf">
<H2>MFC_CString</H2>
<P class="ib">library: classics
header: MFC_CString.h
usage: internal</P>
<P>This is a stand-in for the MFC <code>CString</code> classes.  It exists here so that Classics is not dependant on
the MFC libraries, and because <code>CString</code> as defined in AFX.h uses conditional compilation and cannot handle
8-bit and 16-bit strings in the same program.</P>
<P>The internal structure and memory management matches <code>CString</code>’s, and there is only enough
code supplied to do what <code>ustring</code> needs of it.  This allows <code>ustring</code> to
translate to and from either flavor of <code>CString</code>.</P>
<P>The header file uses conditional compilation to route the <code>::CString</code> type to either
<code>Classics::MFC_CString&lt;char&gt;</code> or <code>Classics::MFC_CString&lt;wchar_t&gt;</code>
depending on the state of the <code>_UNICODE</code> preprocessor symbol.  However, the same Classics
DLL supports both Unicode and non-Unicode versions, and doesn’t care whether you’re using MFC in a DLL
or as a static library.  The single Classics.DLL handles all cases.</P>
<P>For more information, see <A HREF="classics/ustring.html#CString_support"><I>CString Support</I></A>
in the <code>ustring</code> documentation.
</P>

<HR id="Ms">
<H2 id="MSG">MSG</H2>
<P class="ib">library: RatWin
header: message=struct.h or message.h
usage: public</P>

<P>This is the same structure as defined in <code>WINDOWS.H</code> with that name.</P>
<P>See also <A HREF="#sMSG" class="code">sMSG</A>.


<A NAME="N"></A>

<HR id="No">
<H2>noisy1</H2>
<P class="ib">library: classics
header: debug.h
usage: debugging</P>
<P>This is used as a base class to make an object announce its construction
and destruction.
</P>


<HR id="Nt">
<H2>nt_base</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>

<P>This class is a non-template base class to factor out common code in the <A HREF="#vararray" class="code">vararray</A> template.
</P>

<A NAME="O"></A>
<HR>
<H2>OleItemContainer_impl</H2>
<P class="ib">library: classics
header: COM\OleItemContainer_impl.h
usage: main API</P>
<P>This is a starter implementation for supporting the <code>IOleItemContainer</code> interface.
</P>



<A NAME="P"></A>

<HR id="Pc">
<H2 id="filename_t::PC_filesystem_t">PC_filesystem_t</H2>
<P class="ib">library: classics
header: filename.h
usage: advanced API</P>
<P>
This concrete class is derived from <A HREF="#filename_t::filesystem_t"><code>filesystem_t</code></A>
and provides details on the parsing of file names and manipulation of the
file system.  An instance to this class is provided in the static member
<code>filename_t::PC_filesystem</code>.
</P>


<HR id="Pe">
<H2>peremptory</H2>
<P class="ib">library: classics
header: peremptory.h
usage: main API</P>
<P> peremptory: \Per"emp*to*ry\ Not allowing contradiction or refusal; imperative.
  This template is used to ensure that a global variable is constructed either at
  first use (thus avoiding the static constructor ordering issues), or still initialized before
  <code>main()</code> even if not used before then.</P>
<P>
  This is particulary necessary for mutual exclusion control objects, since they
  must be initialized before theading starts or you need another control object
  to control access to it while creating it, ad infinitum.  No additional threads can
  be started during global construction phase before <code>main()</code> is called, so this fills
  that purpose.
</P>


<HR id="Po">
<H2 id="pool_mixin">pool_mixin</H2>
<P class="ib">library: classics
header: fixed_memory_pool.h
usage: main API, <EM>deprecated</EM>
</P>
<P>A helper class for ease of using the <A HREF="#static_fixed_memory_pool" class="code">static_fixed_memory_pool</A>. See
<A HREF="fixed_memory_pool.html#canned" class="code">fixed memory pool</A> documentation.
</P>


<HR id="Pr">
<H2>profile_timer</H2>
<P class="ib">library: classics
header: profile_timer.h
usage: main API</P>
<P>
A mechanism for timing regions of code.  It measures thread time, not wall-clock time,
so it’s primarily used to profile code.
</P>
<p>See <A HREF="Classics/profile_timer.html" class="code">profile_timer</a> documentation.</p>


<HR>
<H2>prothonotary</H2>
<P class="ib">library: classics
header: COM\prothonotary.h
usage: main API</P>
<P>
This registers and unregisters a COM server.
</P>
<p>See <A HREF="Classics/prothonotary.html#toptop" class="code">prothonotary</a> documentation.</p>

<A NAME="R"></A>

<HR id="Re">
<H2 id="exception::register_callback">register_callback, exception</H2>
<P class="ib">library: classics
header: exception.h
usage: main API</P>
<P>
This class’s constructor registers an <A
HREF="#exception::callback" class="code">exception::callback</A>, and its destructor
revokes it.
See the <A HREF="Classics/exception_callback.html">documentation</A> for details.
</P>


<HR>
<H2 id="registry_key">registry_key</H2>
<P class="ib">library: classics
header: registry.h
usage: main API</P>
<P>
...<BR>
See the <A HREF="Classics/registry_guide.html#toptop">documentation</A> for details.
</P>


<A NAME="S"></A>

<HR>
<H2 id="s_data_t">s_data_t</H2>
<P class="ib">library: classics
header: vararray.h
usage: internal</P>

<P>This is a concrete form of the <A HREF="#data_t" class="code">data_t</A> class (see above) that’s used with
the <A HREF="#vararray_s" class="code">vararray_s</A>.  Unlike <A HREF="#g_data_t" class="code">g_data_t</A>, this class is not a template and a single
implementation is shared among all species of <A HREF="#vararray_s" class="code">vararray_s</A>.
</P>


<HR id="Sc">
<H2>schedule_t</H2>
<P class="ib">library: classics
header: schedule_t.h
usage: main API</P>
<P>This enumeration holds a priority value.  16 bits are used to provide for
fine-grained control.  High bits (in a 32-bit word) are used as flags.
</P>


<HR id="Sm">
<H2 id="sMSG">sMSG</H2>
<P class="ib">library: RatWin
header: message=struct.h or message.h
usage: public</P>

<P>This is a <I>simple message</I> structure used to hold the items normally passed to WinProc (and related)
callback functions: <code>hwnd</code>, <code>message</code>, <code>wParam</code>, and <code>lParam</code>.</P>
<P>This isn’t called <A HREF="#MSG" class="code">MSG</A> because <code>WINDOWS.H</code> already
defines that name as a larger structure, so RatWin uses <code>MSG</code> for the same purpose.</P>
<P>The <code>sMSG</code> struct and the specific message-cracker structs are described in the
RatWin <A HREF="RatWin/message_crack_index.html" TARGET="index">Message Cracker</A> documentation.</P>

<HR id="Sn">
<H2>snoop_t</H2>
<P class="ib">library: classics
header: vararray.h
usage: debugging</P>
<P>This data structure is used with the
<A HREF="Classics/vararray.html#debug_snoop" TARGET="info" class="code">debug_snoop</A>
function to spy on the internal state of the <code>vararray</code>.
</P>


<HR id="St">
<H2 id="static_fixed_memory_pool">static_fixed_memory_pool</H2>
<P class="ib">library: classics
header: fixed_memory_pool.h
usage: main API
</P>
<P>Efficient small block allocation, including support for global static objects.  See
<A HREF="Classics/fixed_memory_pool.html#toptop">fixed memory pool</A> documentation.
</P>

<HR>
<H2 id="string">string</H2>
<P class="ib">library: classics
header: string.h, string_ios.h
usage: main API</P>
<P>This is a typedef for <code>generic_string&lt;char&gt;</code>.  It is a string of 8-bit characters.</P>
<P>See <A HREF="Classics/string.html">string</A> documentation</P>


<A NAME="T"></A>

<HR id="Tr">
<H2 id="trug">trug</H2>
<P class="ib">library: classics
header: trug.h
usage: template, main API</P>

<P>A <I>trug</I> is a general container.  It holds something else.  The term <I>trug</I> can be used to refer to any
concrete implementation of the proper interface (see <A HREF="#hypothetical_trug" class="code">hypothetical_trug</A>),
and the actual template named trug has a few supplied specializations.</P>

<P>A trug of a pointer type, e.g. <code>trug&lt;int*></code>, provides strict ownership semantics
and automatic destruction for pointers, similarly to the standard <code>std::auto_ptr</code> class.</P>

<P>A trug of a Windows <code>HANDLE</code> type provides strict ownership and automatic destruction in an analogous way
to the pointers.  For example, <code>trug&lt;HKEY></code> knows to call the Win32 API function <code>RegCloseKey</code>
when &ldquo;freed&rdquo;.</P>

<P>See the <A HREF="Classics/trug_index.html" TARGET="index">trug documentation index</A> for details.</P>



<HR>
<H2>tristate</H2>
<P class="ib">library: classics
header: misc_types.h
usage: main API
</P>
<P>
Used for 3-value logic, particularly in representing user’s settings.  Values are <code>Yes</code> and
<code>No</code> for normal logic, plus a third state which can be called either
<code>Maybe</code> or <code>Automatic</code>.
</P>


<HR id="Ts">
<H2 id="ts_pool_mixin">ts_pool_mixin</H2>
<P class="ib">library: classics
header: fixed_memory_pool.h
usage: main API
</P>
<P>A helper class for ease of using the <A HREF="#ts_static_fixed_memory_pool" class="code">static_fixed_memory_pool</A>. See
<A HREF="fixed_memory_pool.html#canned">fixed memory pool</A> documentation.
</P>


<HR>
<H2 id="ts_static_fixed_memory_pool">ts_static_fixed_memory_pool</H2>
<P class="ib">library: classics
header: fixed_memory_pool.h
usage: main API
</P>
<P>A thread-safe version of <A HREF="#static_fixed_memory_pool" class="code">static_fixed_memory_pool</A>.  See
<A HREF="fixed_memory_pool.html">fixed memory pool</A> documentation.
</P>



<A NAME="U"></A>

<HR id="Ul">
<H2>ulong</H2>
<P class="ib">library: classics
header: common.h
usage: main API</P>
<P>
A typedef for <code>unsigned long</code>.
</P>


<HR id="Ur">
<H2 id="filename_t::URL_filesystem_t">URL_filesystem_t</H2>
<P class="ib">library: classics
header: filename.h
usage: advanced API</P>
<P>
This concrete class is derived from <A HREF="#filename_t::filesystem_t"><code>filesystem_t</code></A>
and provides details on the parsing of Universal Resource Locator names
and limited manipulation of the network space as a filesystem.
An instance to this class is provided in the static member
<code>filename_t::URL_filesystem</code>.
</P>


<HR id="Us">
<H2>ushort</H2>
<P class="ib">library: classics
header: common.h
usage: main API</P>
<P>
A typedef for <code>unsigned</code> <code>short</code>.
</P>


<HR>
<H2 id="ustring">ustring</H2>
<P class="ib">library: classics
header: ustring.h
usage: main API</P>
<P>
This is a <i>universal string</i>.  It can be either a wide or narrow string, reducing the number of
signatures when functions need to take either.  It also serves to translate between wide and
narrow strings, and to translate between string classes from any library.</P>

<P>see <A HREF="Classics/ustring.html#toptop" TARGET="info"><code>ustring</code> documentation</A>.
</P>


<A NAME="V"></A>

<HR id="Va">
<H2 id="vararray">vararray</H2>
<P class="ib">library: classics
header: vararray.h
usage: main API, abstract base</P>

<P>The vararray template is the primary “array-like” collection class.  It is an abstract
base class holding the bulk of the implementation, with concrete derived templates <code>vararray_s</code> and
<code>vararray_g</code> (see below) used in actual variable definitions.</P>
<P>see <A HREF="Classics/vararray_index.html" TARGET="index">reference</A>
or <A HREF="Classics/vararray_guide.html" TARGET="info">User’s Guide</A>.
</P>



<HR>
<H2 id="vararray_g">vararray_g</H2>
<P class="ib">library: classics
header: vararray.h
usage: template, main API</P>

<P>This template is for variable-sized arrays in the general case (<code>_g</code> for <I>general</I>).
Specifically, it does handle elements with constructors and destructors.
</P>
<P>see <A HREF="Classics/vararray_index.html" TARGET="index">reference</A>
or <A HREF="Classics/vararray_guide.html" TARGET="info">User’s Guide</A> for
the general vararray class.
</P>


<HR>
<H2>vararray_s</H2>
<P class="ib">library: classics
header: vararray.h
usage: template, main API</P>

<P>This template is a more efficient streamlined vararray for the special case
when the element is a simple type (<code>_s</code> for <I>simple</I>).
Specifically, it uses memcpy to move elements around, and performs no special initialization
or cleanup.  Contrast with <code>vararray_g</code> above.
</P>
<P>see <A HREF="Classics/vararray_index.html" TARGET="index">reference</A>
or <A HREF="Classics/vararray_guide.html" TARGET="info">User’s Guide</A> for
the general vararray class.
</P>


<A NAME="W"></A>

<HR id="Wi">
<H2 id="win_exception">win_exception</H2>
<P class="ib">library: classics
header: exception.h
usage: main API</P>
<P>
This is derived from <A HREF="#exception">classics::exception</A>.  It is used for Win32 errors, as it knows
about <code>GetLastError</code> and how to look up the description for an error code.
</P>

<HR id="Wn">
<H2 id="WNDPROC_2">WNDPROC_2</H2>
<P class="ib">library: ratwin
header: window=struct.h
namespace: ratwin::window
usage: main API</P>
<P>
This is the same as a WNDPROC, except it is declared to take a <A HREF="#sMSG" class="code">sMSG</A>
structure instead of four separate arguments.</P>
<PRE class="code">
typedef long (__stdcall* WNDPROC_2)(message::sMSG);
</PRE>


<HR id="Ws">
<H2><A NAME="wstring">wstring</A></H2>
<P class="ib">library: classics
header: string.h, string_ios.h
usage: main API</P>
<P>This is a typedef for <code>generic_string&lt;wchar_t&gt;</code>.  It is a string of 16-bit characters.</P>
<P>See <A HREF="Classics/string.html" class="code">wstring</A> documentation</P>

<A NAME="X"></A>

<HR id="Xw">
<H2 id="xwstring">xwstring</H2>
<P class="ib">library: classics
header: string.h, string_ios.h
usage: main API</P>
<P>This is a typedef for <code>generic_string&lt;unsigned __int32&gt;</code>.  It is a string of 32-bit characters.</P>
<P>See <A HREF="Classics/string.html" class="code">xwstring</A> documentation</P>


</BODY>
</HTML>

