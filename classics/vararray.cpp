// The Repertoire Project copyright 2006 by John M. Dlugosz : see <http://www.dlugosz.com/Repertoire/>
// File: classics\vararray.cpp
// Revision: public build 8, shipped on 11-July-2006

#define CLASSICS_EXPORT __declspec(dllexport)
#include "classics\new.h"
#include "classics\vararray.h"
#include "classics\exception.h"
#include "classics\string_ios.h"  //for formatting error messages
#include <iostream>  // for debug_print()
#include <string.h>

STARTWRAP
namespace classics {
using std::endl;
using std::cout;

using namespace vararray_internal;

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */

void intermediate::debug_print() const
 {
 cout << "intermediate at " << (void*)this << " contains pointer to " << data()
    << " refcount= " << get_reference_count() << endl;
 const_object()->debug_print();
 }

void chdata::debug_print() const
 {
 cout << "chdata at " << (void*)this << " contains pointer to " << data() << endl;
 const_object()->debug_print();
 }

void nt_base::debug_print() const
 {
 cout << "vararray non-template base at " << (void*)this << endl;
 data.debug_print();
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */

inline
void data_t::debug_snoop (snoop_t& results) const
 {
 results.core= this;
 }

inline
void intermediate::debug_snoop (snoop_t& results) const
 {
 results.h2= this;
 const_object()->debug_snoop (results);
 }

void chdata::debug_snoop (snoop_t& results) const
 {
 results.h1= this;
 const_object()->debug_snoop (results);
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */


nt_base::nt_base (data_t* core)
 : data (new intermediate (core))
 { }

s_data_ntbase::s_data_ntbase (int elsize, int elcount)
 : copy_semantics_s (elsize), data_t (elsize, elcount)
 {
 initialize_all();
 }

s_data_ntbase::s_data_ntbase (int elsize, int elcount, int capacity)
 : copy_semantics_s (elsize), data_t (elsize, elcount, capacity)
 {
 initialize_all();
 }

s_data_ntbase::s_data_ntbase (int elsize, int elcount, const void* data)
 : copy_semantics_s (elsize), data_t (elsize, elcount)
 {
 initialize_all (data);
 }

s_data_ntbase::s_data_ntbase (const s_data_ntbase& other)
 : copy_semantics_s (other.data_t::Elsize), data_t (other.data_t::Elsize, other.elcount())
 {
 initialize_all (other);
 }


nt_base::nt_base (const nt_base& other)
 : data (new intermediate (*other.data.get_data()))
 { }

void nt_base::operator= (const nt_base& other)
 {
 if (this != &other)
    data= new intermediate (*other.data.get_data());
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */

bool intermediate::lazy_dup_core (data_t*&core)
 {
 const data_t* x= const_object();
 int refcount= x->get_reference_count();
 core= const_cast<data_t*>(x);
 return refcount != 1;
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */

void nt_base::resize (int newsize)
 {
 data_t* core;
 if (lazy_dup_core (core)) {
    // I have to make a copy
    data_t* newcore= core->resize_duplicate (newsize);
    set_core (newcore);
    }
 else {
    // I modify the existing copy
    core->resize (newsize, newsize);
    }
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */

void nt_base::replace (int pos, int lendel, const void* data, int datalen)
 {
 // >> add range checking ... or just add to the error generated by the primitives?
 data_t* old;
 bool shared= lazy_dup_core(old);
 const int oldcount= old->elcount();
 const int newsize= oldcount - lendel + datalen;
 if (shared || newsize > old->elcapacity() || old->same_object(pos, data, datalen) ) {
    // I have to make a copy.  Compose the result into the copy.
    data_t* core= old->clone_empty (newsize);
    core->splice_result (old->get_buffer(), oldcount, pos, lendel, data, datalen);
    set_core (core);
    }
 else {
    // I can modify the existing copy in-place
    old->splice_result_inplace (pos, lendel, data, datalen);
    }
 }

/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */


}
ENDWRAP

